import ghpythonlib.components as gh
import rhinoscriptsyntax as rs 
import Rhino as rc 
import scriptcontext as sc
import math
import random 
import operator
import itertools

#class object initialized with "room" data 
#   -self.x & self.y: store midpoint lines generated by mepCross()
#   -self.x_range & self.y_range: extract and store the span of their respective midline 
class mepSpan:  
    def __init__(self,room):
        self.x, self.y = self.mepCross(room)
        self.x_range = [round(min(self.x[0][0],self.x[1][0])),round(max(self.x[0][0],self.x[1][0]))]
        self.y_range = [round(min(self.y[0][1],self.y[1][1])),round(max(self.y[0][1],self.y[1][1]))]
        self.x_channel = []
        self.y_channel = []
    #calculates the difference of a given x_range or y_range
    def rangeLength(self,range):
        return range[1]-range[0]
        
    #returns the midpoint lines of a given parallelogram 
    #draws a line between the midpoint of opposing line segments 
    #NB: the ordering of segments resulting from gh.Explode() is not standard
    #   -to assign segment to appropriate variable (x or y), take the crossproduct of segment A and unit X
    def mepCross(self,room):
        edges = gh.Explode(room,True).segments
        edges = gh.Pufferfish.ReparameterizeCurve(edges).reparameterized
        a = gh.Line(gh.EvaluateCurve(edges[0],0.5).point,gh.EvaluateCurve(edges[2],0.5).point)
        b = gh.Line(gh.EvaluateCurve(edges[1],0.5).point,gh.EvaluateCurve(edges[3],0.5).point)
        if(gh.CrossProduct(gh.UnitY(1),a,True).length):
            return a,b
        else:
            return b,a
    
    def addChannel(self,dir,vect):
        if(dir=='x'):
            self.x_channel.append(gh.Move(self.x,vect).geometry)
        else: 
            self.y_channel.append(gh.Move(self.y,vect).geometry)
            
#generic print function for debugging 
#prints the original (enumerated) index of spans as they appear in current 2D structuring
def printIndices(spans):
    ind = []
    for i in spans: 
        bunch = [] 
        for j in i:
            bunch.append(j[0])
        ind.append(bunch)
    print(ind)
    return(ind)

def overlappingSpans(spans,cur,dir,opdir):
    east, west = zip(*[getattr(obj[1],dir) for obj in spans])
    cur_east = getattr(cur[1],dir)[0]
    cur_west = getattr(cur[1],dir)[1]
    min_lap = min(20,abs(cur_west-cur_east)/8)
    overlapping = [cur]
    for i in range(len(spans)):
        if(cur_east+min_lap<west[i] and cur_west-min_lap>east[i]):
            overlapping.append(spans[i])
    #printIndices([overlapping])
    contig = []
    if(len(overlapping)>1):
        north,south = [list(a) for a in zip(*[getattr(obj[1],opdir) for obj in overlapping])]
        for j in range(len(overlapping)):
            cur_north = north[j]
            cur_south = south[j]
            if(cur[0]==4):
                print(overlapping[j][0],cur_north,cur_south)
            if(cur_north in south or cur_south in north):
                contig.append(overlapping[j])
            elif(j==0):
                break
    printIndices([contig])
    if(contig==[]):
        contig.append(overlapping[0])
    return contig

def reqColinear (spans,dir,opdir):
    colinear = []
    col_set = []
    enum = list(enumerate(spans))
    if(len(enum)==1):
        col_set.append(enum)
    else:
        for i in range(len(enum)):
            colinear.append(sorted(overlappingSpans(enum[:i]+enum[i+1:],enum[i],dir,opdir)))
        col_set = [list(y) for y in set(tuple(x) for x in colinear)]
        for i in range(2,len(col_set)):
            for x in itertools.combinations(col_set,i):
                check_set = sorted(set().union(*x))
                if(check_set in col_set):
                    col_set.remove(check_set)
    return col_set

def placeMEP(colinear,dir):
    #dictionary to handle x and y flows 
    dict = {'x_range':['y_range','x',1,lambda f: gh.UnitY(f)],
            'y_range':['x_range','y',0,lambda f: gh.UnitX(f)]}
    if(len(colinear)==1):
        colinear[0][0][1].addChannel(dir[0],dict[dir][-1](0))
    else:
        for i in range(len(colinear)):
            if(len(colinear[i])==1):
                colinear[i][0][1].addChannel(dir[0],dict[dir][-1](0))
            else:
                op_start, op_stop = zip(*[getattr(obj[1],dict[dir][0]) for obj in colinear[i]])
                mdpnt = max(op_start)+(min(op_stop)-max(op_start))/2
                for k in range(len(colinear[i])):
                    span = colinear[i][k][1]
                    mep = getattr(span,dict[dir][1])
                    dif = mdpnt-mep[0][dict[dir][2]]
                    span.addChannel(dir[0],dict[dir][-1](dif))
spans = []  
for ele in regions:
    ele = mepSpan(ele)
    spans.append(ele)

xcol = reqColinear(spans,'x_range','y_range')
printIndices(xcol)
placeMEP(xcol,'y_range')
#printIndices(xcol)

#sortalgo = lambda e: (-e[1].y_range[0],-(e[1].rangeLength(e[1].y_range)))
ycol = reqColinear(spans,'y_range','x_range')
printIndices(ycol)
placeMEP(ycol,'x_range')
#printIndices(ycol)

mepx = []
mepy = []
for i in range(len(spans)):
    for j in spans[i].y_channel:
        mepy.append(j)
    for k in spans[i].x_channel:
        mepx.append(k)

        
    

